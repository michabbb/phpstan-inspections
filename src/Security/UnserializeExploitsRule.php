<?php declare(strict_types=1);

namespace macropage\PHPStan\Inspections\Security;

use PhpParser\Node;
use PhpParser\Node\Expr\ArrayDimFetch;
use PhpParser\Node\Expr\FuncCall;
use PhpParser\Node\Expr\Variable;
use PhpParser\NodeFinder;
use PhpParser\NodeVisitorAbstract;
use PHPStan\Analyser\Scope;
use PHPStan\Rules\Rule;
use PHPStan\Rules\RuleErrorBuilder;
use PHPStan\Type\Constant\ConstantArrayType;
use PHPStan\Type\Constant\ConstantBooleanType;
use PHPStan\Type\TypeCombinator;

/**
 * Detects potential security vulnerabilities in unserialize() function calls.
 *
 * This rule identifies unsafe usage of unserialize() that could be exploited:
 * 1. Missing allowed_classes parameter (PHP 7.0+ security requirement)
 * 2. Unserialize calls with data from untrusted sources like $_GET, $_POST, file_get_contents()
 *
 * Suggests specifying allowed classes and avoiding untrusted input for unserialize().
 *
 * @implements Rule<FuncCall>
 */
final class UnserializeExploitsRule implements Rule
{
    private const MESSAGE_USE_SECOND_ARGUMENT = 'Please specify classes allowed for unserialization in 2nd argument.';
    private const MESSAGE_PATTERN = 'Perhaps it\'s possible to exploit the unserialize via: %s.';

    /** @var string[] */
    private const UNTRUSTED_VARS = ['_GET', '_POST', '_REQUEST', '_FILES', '_COOKIE'];

    /** @var string[] */
    private const UNTRUSTED_FUNCTIONS = ['file_get_contents', 'base64_decode', 'urldecode'];

    public function getNodeType(): string
    {
        return FuncCall::class;
    }

    public function processNode(Node $node, Scope $scope): array
    {
        if (!($node->name instanceof Node\Name)) {
            return [];
        }

        if ($node->name->toLowerString() !== 'unserialize') {
            return [];
        }

        $errors = [];

        // Check 1: Missing second argument (PHP 7.0+ context, always true for this project)
        if (count($node->getArgs()) === 1) {
            $errors[] = RuleErrorBuilder::message(self::MESSAGE_USE_SECOND_ARGUMENT)
                ->identifier('unserialize.missingAllowedClasses')
                ->line($node->getStartLine())
                ->build();
            // Proceed to check for exploits even if the second argument is missing
        } elseif (count($node->getArgs()) === 2) {
            $secondArgValue = $node->getArgs()[1]->value;
            $secondArgType = $scope->getType($secondArgValue);

            // If the second argument is an empty array or `true`
            if (
                ($secondArgType instanceof ConstantArrayType && count($secondArgType->getKeyTypes()) === 0) ||
                ($secondArgType instanceof ConstantBooleanType && $secondArgType->getValue() === true)
            ) {
                $errors[] = RuleErrorBuilder::message(self::MESSAGE_USE_SECOND_ARGUMENT)
                    ->identifier('unserialize.missingAllowedClasses')
                    ->line($node->getStartLine())
                    ->build();
            }
        }

        // Check 2: Exploitable calls
        if (count($node->getArgs()) > 0) {
            $firstArg = $node->getArgs()[0]->value;
            $untrustedSources = $this->findUntrustedSources($firstArg, $scope);

            if (!empty($untrustedSources)) {
                sort($untrustedSources); // Sort for consistent reporting
                $errors[] = RuleErrorBuilder::message(sprintf(self::MESSAGE_PATTERN, implode(', ', $untrustedSources)))
                    ->identifier('unserialize.exploitable')
                    ->line($node->getStartLine())
                    ->build();
            }
        }

        return $errors;
    }

    /**
     * @return string[]
     */
    private function findUntrustedSources(Node $node, Scope $scope): array
    {
        $foundSources = [];
        $nodeFinder = new NodeFinder();

        // Find all relevant nodes within the expression
        $relevantNodes = $nodeFinder->find($node, function (Node $subNode) {
            return $subNode instanceof Variable || $subNode instanceof FuncCall || $subNode instanceof ArrayDimFetch;
        });

        foreach ($relevantNodes as $subNode) {
            if ($subNode instanceof Variable) {
                $varName = $subNode->name instanceof Node\VarLikeIdentifier ? $subNode->name->name : (string) $subNode->name;
                if (in_array($varName, self::UNTRUSTED_VARS, true)) {
                    $foundSources[] = $subNode->name instanceof Node\VarLikeIdentifier ? '$' . $subNode->name->name : '$' . $subNode->name;
                }
            } elseif ($subNode instanceof FuncCall) {
                if ($subNode->name instanceof Node\Name) {
                    $functionName = $subNode->name->toLowerString();
                    if (in_array($functionName, self::UNTRUSTED_FUNCTIONS, true)) {
                        $foundSources[] = $functionName . '(...)';
                    }
                }
            } elseif ($subNode instanceof ArrayDimFetch) {
                // Extract the base variable from array access
                $current = $subNode;
                while ($current instanceof ArrayDimFetch) {
                    $current = $current->var;
                }
                if ($current instanceof Variable) {
                    $varName = $current->name instanceof Node\VarLikeIdentifier ? $current->name->name : (string) $current->name;
                    if (in_array($varName, self::UNTRUSTED_VARS, true)) {
                        $foundSources[] = $current->name instanceof Node\VarLikeIdentifier ? '$' . $current->name->name : '$' . $current->name;
                    }
                }
            }
        }

        return array_unique($foundSources);
    }
}
